<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <title>How X Window Managers Work, And How To Write One (Part II) - Season of Code</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="shortcut icon" href="http://seasonofcode.com/assets/favicon.ico" />
      <link href="http://seasonofcode.com/theme/asciidoc.min.css?0e298cf5" rel="stylesheet" />
    <link href="http://seasonofcode.com/theme/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="http://seasonofcode.com/theme/font-awesome/css/font-awesome.min.css" rel="stylesheet" />
      <link href="http://seasonofcode.com/theme/style.min.css?918c51a9" rel="stylesheet" />
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="http://seasonofcode.com/theme/html5shiv.min.js"></script>
    <script src="http://seasonofcode.com/theme/respond.min.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="http://seasonofcode.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Season of Code Full Atom Feed" />
    <link href="http://seasonofcode.com/feeds/misc.atom.xml" type="application/atom+xml" rel="alternate" title="Season of Code Categories Atom Feed" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-21264754-1', 'auto');
  ga('send', 'pageview');

</script>

    <meta name="google-site-verification" content="g_MrQjKfWWKOccQYg--leY8NlSev0om0sy2vrBLYoZU">
    <meta name="google-site-verification" content="_r0m7LYlH2JjDgeTysX9Fv0OzQG1xUEAU6x2uSr9nH8">

    <meta name="msvalidate.01" content="F10D3C66876F50983761BFE53E2B943A4">

  <link rel="canonical" href="http://seasonofcode.com/posts/how-x-window-managers-work-and-how-to-write-one-part-ii.html">
  </head>
  <body id="index" class="archive">
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
    <nav id="header" class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <i class="fa fa-bars fa-lg"></i>
          </button>
          <a class="navbar-brand" href="http://seasonofcode.com">
            season <span class="of">of</span> code
          </a>
        </div>
        <div class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li>
              <a href="http://seasonofcode.com/tag/featured.html">Featured</a>
            </li>
            <li id="header-tags-dropdown" class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown"
                role="button">Tags <i class="fa fa-caret-down"></i></a>
              <ul class="dropdown-menu">
                  <li><a href="http://seasonofcode.com/tag/android.html">Android</a></li>
                  <li><a href="http://seasonofcode.com/tag/c.html">C++</a></li>
                  <li><a href="http://seasonofcode.com/tag/featured.html">Featured</a></li>
                  <li><a href="http://seasonofcode.com/tag/linux.html">Linux</a></li>
                  <li><a href="http://seasonofcode.com/tag/misc.html">Misc</a></li>
                  <li><a href="http://seasonofcode.com/tag/projects.html">Projects</a></li>
                  <li><a href="http://seasonofcode.com/tag/python.html">Python</a></li>
                  <li><a href="http://seasonofcode.com/tag/window-manager.html">Window Manager</a></li>
              </ul>
            </li>
            <li>
              <a href="http://seasonofcode.com/archives.html">Archives</a>
            </li>
            <li><a href="http://seasonofcode.com/pages/about.html">About</a></li>
          </ul>
        </div>
        <!-- /.navbar-collapse -->
      </div>
    </nav>
    <div class="container">
      <div class="row">
        <div class="col-xs-12 col-md-8 col-md-offset-2">
  <section id="content" class="article content">
<article itemscope itemtype="http://schema.org/Article">
  <header>
    <h2 class="entry-title">
      <a itemprop="name" href="http://seasonofcode.com/posts/how-x-window-managers-work-and-how-to-write-one-part-ii.html" rel="bookmark">
      How X Window Managers Work, And How To Write One (Part II)
      </a>
    </h2>
    <!--googleoff: snippet-->
    <aside>
      <ul class="article-meta text-muted small">
        <li class="article-author">
          By <span itemprop="author">Chuan Ji</span>
        </li>
        <li class="spacer">|</li>
        <li class="article-date">
        <span itemprop="datePublished" content="2014-06-08T23:14:00-07:00">
          Jun 08, 2014
        </span>
        </li>
        <li class="spacer">|</li>
        <li>
          Tags:
            <a href="http://seasonofcode.com/tag/featured.html">Featured</a>,            <a href="http://seasonofcode.com/tag/window-manager.html">Window Manager</a>        </li>
        <li class="spacer">|</li>
        <li class="article-comments-count">
          <a href="http://seasonofcode.com/posts/how-x-window-managers-work-and-how-to-write-one-part-ii.html#disqus_thread">Comments</a>
        </li>
      </ul>
    </aside>
    <!--googleon: snippet-->
  </header>

  <div itemprop="articleBody" class="entry-content">
    <div class="paragraph"><p>In <a href="/posts/how-x-window-managers-work-and-how-to-write-one-part-i.html">Part
I of this series</a>, we examined the role of X window managers on a modern
Linux/BSD desktop, and how they interact with the X server and applications. In
Part II, we will dig down into the dirty details and walk through the code of a
basic reparenting, non-compositing window manager,
<a href="https://github.com/jichuan89/basic_wm">basic_wm</a>.</p></div>
<div class="sect2">
<h3 id="_introduction">Introduction</h3>
<div class="paragraph"><p>Before we start with the code, let&#8217;s go over a couple of basic implementation
choices such as language and API.</p></div>
<div class="sect3">
<h4 id="_language">Language</h4>
<div class="paragraph"><p>You can write a window manager in <a href="http://xmonad.org">Haskell</a>,
<a href="http://qtile.org">Python</a>, <a href="http://www.nongnu.org/stumpwm/">Lisp</a>,
<a href="https://github.com/BurntSushi/wingo">Go</a>,
<a href="http://escher.sourceforge.net/">Java</a>, or any other language that has X bindings
- i.e., a library for talking to an X server.</p></div>
<div class="paragraph"><p>I chose C++ for <a href="https://github.com/jichuan89/basic_wm">basic_wm</a>, our example
window manager, mainly because the C libraries for X11 are the best documented.
In addition to books such as the
<a href="http://www.amazon.com/Programming-Manual-Version-Definitive-Guides/dp/1565920023">Xlib
Programming Manual</a>, documentation can be found in the form of widely available
<a href="http://www.xfree86.org/current/manindex3.html">man pages</a> (e.g., try <code>man
XOpenDisplay</code> at a terminal). Example usage and common patterns abound in the
source code of many great window managers written in the past three decades.</p></div>
<div class="paragraph"><p>We will use C++11 and C++14 features where convenient, so you will need a
compatible compiler (GCC 4.9 or higher, or Clang 3.4 or higher) if you want to
play with the source code.</p></div>
</div>
<div class="sect3">
<h4 id="a-tale-of-two-x-libraries">A Tale of Two X Libraries</h4>
<div class="paragraph"><p>There are two official C libraries for X:
<a href="http://en.wikipedia.org/wiki/Xlib">Xlib</a> and
<a href="http://en.wikipedia.org/wiki/Xcb">XCB</a>. Xlib, hailing from 1985, was the original
X client library, and was the only official X client library until the
introduction of XCB in 2001. The two libraries have very different philosophies:
whereas Xlib tries to hide the X protocol behind a friendly C API with lots of
bells and whistles, XCB directly exposes the plumbing beneath.</p></div>
<div class="paragraph"><p>In practice, this different manifests itself most prominently in how the two
libraries handle the fundamental asynchronous nature of the X protocol. Xlib
attempts to hide the asynchronous X protocol behind a mixed
synchronous and asynchronous API, whereas XCB is fully asynchronous.</p></div>
<div class="paragraph"><p>For example, to lookup the attributes (e.g., size and position) of a window, you
would write the following using Xlib:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="n">XWindowAttributes</span> <span class="n">attrs</span><span class="p">;</span>
<span class="n">XGetWindowAttributes</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attrs</span><span class="p">);</span>
<span class="c1">// Do stuff.</span>
</pre></div></div></div>
<div class="paragraph"><p>Under the hood,
<a href="http://manpages.ubuntu.com/manpages/en/man3/XGetWindowAttributes.3.html"><code>XGetWindowAttributes</code>()</a>
sends a request to the X server and blocks until it receives a response; in
other words, it is <em>synchronous</em>. On the other hand, using XCB, you would write
this instead:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="kt">xcb_get_window_attributes_cookie_t</span> <span class="n">cookie</span> <span class="o">=</span>
    <span class="n">xcb_get_window_attributes</span><span class="p">(</span>
        <span class="n">connection</span><span class="p">,</span> <span class="n">window</span><span class="p">);</span>
<span class="c1">// Do other stuff while waiting for reply.</span>
<span class="kt">xcb_get_window_attributes_reply_t</span><span class="o">*</span> <span class="n">reply</span> <span class="o">=</span>
    <span class="n">xcb_get_window_attributes_reply</span><span class="p">(</span>
        <span class="n">connection</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
<span class="c1">// Do stuff.</span>
<span class="n">free</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>The function <code>xcb_get_window_attributes</code> merely sends the request to the X
server, and returns immediately without waiting for the reply; in other words,
it is <em>asynchronous</em>. The client program must subsequently call
<code>xcb_get_window_attributes_reply</code> to block on the response.</p></div>
<div class="paragraph"><p>The advantage of the asynchronous approach is obvious if we consider an example
where we need to retrieve the attributes of, say, 5 windows. Using XCB, we can
fire off all 5 requests to the X server at once, and then wait for 5 responses.
With Xlib, we have to wait for the response to each request before we can send
the next one. Therefore, we only block for one round-trip network latency using
XCB, compared to 5 with Xlib.</p></div>
<div class="paragraph"><p>The downside of XCB&#8217;s fully asynchronous approach is verbosity and a less
programmer-friendly API.  The Xlib code above looks like your average C library
call; the XCB code above is significantly more involved.</p></div>
<div class="paragraph"><p>However, it is important to note that whereas XCB is fully asynchronous, Xlib
isn&#8217;t fully synchronous; rather, <strong>Xlib has a mixture of synchronous and
asynchronous APIs</strong>. In general, functions that do not return values (e.g.,
<a href="http://manpages.ubuntu.com/manpages/en/man3/XConfigureWindow.3.html">XResizeWindow</a>,
which changes the size of a window) are asynchronous, while functions that
return values (e.g.,
<a href="http://manpages.ubuntu.com/manpages/en/man3/XGetWindowAttributes.3.html">XGetGeometry</a>,
which return the size and position of a window) are synchronous:</p></div>
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>Xlib saves up requests instead of sending them to the server immediately, so
that the client program can continue running instead of waiting to gain access
to the network after every Xlib call. This is possible because most Xlib calls
do not require immediate action by the server. This grouping of requests by the
client before sending them over the network also increases the performance of
most networks, because it makes the network transactions longer and less
numerous, reducing the total overhead involved.</p></div>
<div class="paragraph"><p>Xlib sends the buffer full of requests to the server under three conditions.</p></div>
<div class="paragraph"><p>The most common is when an application calls an Xlib routine to wait for an
event but no matching event is currently available on Xlib’s queue. Since, in
this case, the application must wait for an appropriate event anyway, it makes
sense to flush the request buffer.</p></div>
<div class="paragraph"><p>Second, Xlib calls that get information from the server require a reply before
the program can continue, and therefore, the request buffer is sent and all the
requests acted on before the information is returned.</p></div>
<div class="paragraph"><p>Third, the client would like to be able to flush the request buffer manually in
situations where no user events and no calls to query the server are expected.
One good example of this third case is an animated game, where the display
changes even when there is no user input.</p></div>
</div>
<div class="attribution">
&#8212; Xlib Programming Manual §2.1.2
</div></div>
<div class="paragraph"><p>This is <em>the</em> most confusing aspect of Xlib, and was a source of endless
frustration for those new to X programming. One of the major motivations for the
creation of XCB was to eliminate this unnecessary complexity.</p></div>
<div class="paragraph"><p>Most popular window managers have already been ported to XCB from Xlib for the
performance benefits. (If you are interested, you can read up on
<a href="http://www.mini-dweeb.org/~arnau/docs/dueti/project/report.pdf">how they ported
Awesome</a> and
<a href="http://blog.martin-graesslin.com/blog/2013/02/porting-kwin-to-xcb-making-c-usable-through-raii/">KWin</a>).
I chose Xlib for <a href="https://github.com/jichuan89/basic_wm">basic_wm</a>, however,
because for pedagogical example code readability is of course much more
important than performance. In fact, I would recommend starting with Xlib first
for any project and worry about porting to XCB later, as Xlib is much easier to
work with.</p></div>
<div class="paragraph"><p>While an in-depth discussion of the merits of Xlib and XCB is beyond the scope
of this discussion, I do recommend you check out
<a href="http://www.x.org/wiki/guide/xlib-and-xcb/">the official article on Xlib vs. XCB</a>
as it presents a fascinating case study of API design.</p></div>
</div>
<div class="sect3">
<h4 id="_dependencies_and_building">Dependencies and Building</h4>
<div class="paragraph"><p>The only additional library used by the example
<a href="https://github.com/jichuan89/basic_wm">basic_wm</a> code is
<a href="https://code.google.com/p/google-glog/">google-glog</a>, Google&#8217;s open source C++
logging library. (It is available on Debian/Ubuntu as <code>libgoogle-glog-dev</code>, on
Fedora as <code>glog</code>, and on Arch Linux as <code>google-glog</code>.)</p></div>
<div class="paragraph"><p>The recommended way to build the source code is with
<a href="http://www.scons.org/">SCons</a>, although <code>g++ *.cpp</code> will also do the trick if you
supply all the libraries correctly.</p></div>
<div class="paragraph"><p>To test it, you will likely need
<a href="http://www.freedesktop.org/wiki/Software/Xephyr/">Xephyr</a> along with a couple of
simple X programs such as <code>xeyes</code> or <code>xterm</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_step_1_setup_and_teardown">Step 1: Setup and Teardown</h3>
<div class="paragraph"><p>Let&#8217;s start off with a skeleton implementation of the <code>WindowManager</code> class,
which will encapsulate all the window management logic in our example. All it
will do for now is set up a connection to the X server on construction, and
close that connection on destruction.</p></div>
<div class="paragraph"><p>In
<a href="https://github.com/jichuan89/basic_wm/blob/master/window_manager.hpp"><code>window_manager.hpp</code></a>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#include &lt;X11/Xlib.h&gt;</span>
<span class="p">}</span>
<span class="cp">#include &lt;memory&gt;</span>

<span class="k">class</span> <span class="nc">WindowManager</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Factory method for establishing a connection to an X server and creating a</span>
  <span class="c1">// WindowManager instance.</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">WindowManager</span><span class="o">&gt;</span> <span class="n">Create</span><span class="p">();</span>
  <span class="c1">// Disconnects from the X server.</span>
  <span class="o">~</span><span class="n">WindowManager</span><span class="p">();</span>
  <span class="c1">// The entry point to this class. Enters the main event loop.</span>
  <span class="kt">void</span> <span class="nf">Run</span><span class="p">();</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="c1">// Invoked internally by Create().</span>
  <span class="n">WindowManager</span><span class="p">(</span><span class="n">Display</span><span class="o">*</span> <span class="n">display</span><span class="p">);</span>

  <span class="c1">// Handle to the underlying Xlib Display struct.</span>
  <span class="n">Display</span><span class="o">*</span> <span class="n">display_</span><span class="p">;</span>
  <span class="c1">// Handle to root window.</span>
  <span class="k">const</span> <span class="n">Window</span> <span class="n">root_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>In
<a href="https://github.com/jichuan89/basic_wm/blob/master/window_manager.cpp"><code>window_manager.cpp</code></a>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &quot;window_manager.hpp&quot;</span>
<span class="cp">#include &lt;glog/logging.h&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">WindowManager</span><span class="o">&gt;</span> <span class="n">WindowManager</span><span class="o">::</span><span class="n">Create</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 1. Open X display.</span>
  <span class="n">Display</span><span class="o">*</span> <span class="n">display</span> <span class="o">=</span> <span class="n">XOpenDisplay</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">display</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Failed to open X display &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">XDisplayName</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 2. Construct WindowManager instance.</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">WindowManager</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">WindowManager</span><span class="p">(</span><span class="n">display</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">WindowManager</span><span class="o">::</span><span class="n">WindowManager</span><span class="p">(</span><span class="n">Display</span><span class="o">*</span> <span class="n">display</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">display_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">display</span><span class="p">)),</span>
      <span class="n">root_</span><span class="p">(</span><span class="n">DefaultRootWindow</span><span class="p">(</span><span class="n">display_</span><span class="p">))</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">WindowManager</span><span class="o">::~</span><span class="n">WindowManager</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">XCloseDisplay</span><span class="p">(</span><span class="n">display_</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">WindowManager</span><span class="o">::</span><span class="n">Run</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* TODO */</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>The <code>main</code> function in
<a href="https://github.com/jichuan89/basic_wm/blob/master/main.cpp"><code>main.cpp</code></a>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="cp">#include &lt;cstdlib&gt;</span>
<span class="cp">#include &lt;glog/logging.h&gt;</span>
<span class="cp">#include &quot;window_manager.hpp&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">google</span><span class="o">::</span><span class="n">InitGoogleLogging</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">WindowManager</span><span class="o">&gt;</span> <span class="n">window_manager</span><span class="p">(</span><span class="n">WindowManager</span><span class="o">::</span><span class="n">Create</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">window_manager</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Failed to initialize window manager.&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">window_manager</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Even if you have never programmed Xlib before, this should not be hard to
understand. <code>WindowManager::Create()</code> is a
<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Doing_Work_in_Constructors">static
factory method</a> that sets up a connection to an X server via
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man3/XOpenDisplay.3.html"><code>XOpenDisplay()</code></a>;
we will let
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man3/XOpenDisplay.3.html"><code>XOpenDisplay()</code></a>
figure out which X server to connect to from the <code>DISPLAY</code> environment variable.
The connection is represented by the opaque <code>Display</code> structure. We call
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man3/XOpenDisplay.3.html"><code>XCloseDisplay()</code></a>
on the saved <code>Display*</code> in the destructor to close the connection.</p></div>
<div class="paragraph"><p>The other function of note is
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man3/AllPlanes.3.html"><code>DefaultRootWindow()</code></a>,
which returns the default root window for a given X server. Technically, an X
server may have several root windows in some rare multihead setups, but let&#8217;s
not worry about that here.</p></div>
<div class="paragraph"><p>If you run this program now, it should connect to the X server, close the
connection, and exit. Hooray!</p></div>
</div>
<div class="sect2">
<h3 id="_step_2_initialization">Step 2: Initialization</h3>
<div class="paragraph"><p>Now, let&#8217;s dig into the mysterious <code>Run()</code> function above. We&#8217;ll start with the
initialization steps required after opening an X server connection.
In
<a href="https://github.com/jichuan89/basic_wm/blob/master/window_manager.hpp"><code>window_manager.hpp</code></a>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="k">class</span> <span class="nc">WindowManager</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Xlib error handler.</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">OnXError</span><span class="p">(</span><span class="n">Display</span><span class="o">*</span> <span class="n">display</span><span class="p">,</span> <span class="n">XErrorEvent</span><span class="o">*</span> <span class="n">e</span><span class="p">);</span>
  <span class="c1">// Xlib error handler used to determine whether another window manager is</span>
  <span class="c1">// running. It is set as the error handler right before selecting substructure</span>
  <span class="c1">// redirection mask on the root window, so it is invoked if and only if</span>
  <span class="c1">// another window manager is running.</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">OnWMDetected</span><span class="p">(</span><span class="n">Display</span><span class="o">*</span> <span class="n">display</span><span class="p">,</span> <span class="n">XErrorEvent</span><span class="o">*</span> <span class="n">e</span><span class="p">);</span>
  <span class="c1">// Whether an existing window manager has been detected. Set by OnWMDetected.</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">wm_detected_</span><span class="p">;</span>
  <span class="c1">// A mutex for protecting wm_detected_.</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">wm_detected_mutex_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>In
<a href="https://github.com/jichuan89/basic_wm/blob/master/window_manager.cpp"><code>window_manager.cpp</code></a>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="kt">void</span> <span class="n">WindowManager</span><span class="o">::</span><span class="n">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 1. Initialization.</span>
  <span class="c1">//   a. Select events on root window. Use a special error handler so we can</span>
  <span class="c1">//   exit gracefully if another window manager is already running.</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">wm_detected_mutex_</span><span class="p">);</span>

    <span class="n">wm_detected_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">XSetErrorHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">WindowManager</span><span class="o">::</span><span class="n">OnWMDetected</span><span class="p">);</span>
    <span class="n">XSelectInput</span><span class="p">(</span>
        <span class="n">display_</span><span class="p">,</span>
        <span class="n">root_</span><span class="p">,</span>
        <span class="n">SubstructureRedirectMask</span> <span class="o">|</span> <span class="n">SubstructureNotifyMask</span><span class="p">);</span>
    <span class="n">XSync</span><span class="p">(</span><span class="n">display_</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wm_detected_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Detected another window manager on display &quot;</span>
                 <span class="o">&lt;&lt;</span> <span class="n">XDisplayString</span><span class="p">(</span><span class="n">display_</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">//   b. Set error handler.</span>
  <span class="n">XSetErrorHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">WindowManager</span><span class="o">::</span><span class="n">OnXError</span><span class="p">);</span>

  <span class="c1">// 2. Main event loop.</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">WindowManager</span><span class="o">::</span><span class="n">OnWMDetected</span><span class="p">(</span><span class="n">Display</span><span class="o">*</span> <span class="n">display</span><span class="p">,</span> <span class="n">XErrorEvent</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// In the case of an already running window manager, the error code from</span>
  <span class="c1">// XSelectInput is BadAccess. We don&#39;t expect this handler to receive any</span>
  <span class="c1">// other errors.</span>
  <span class="n">CHECK_EQ</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">error_code</span><span class="p">),</span> <span class="n">BadAccess</span><span class="p">);</span>
  <span class="c1">// Set flag.</span>
  <span class="n">wm_detected_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="c1">// The return value is ignored.</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">WindowManager</span><span class="o">::</span><span class="n">OnXError</span><span class="p">(</span><span class="n">Display</span><span class="o">*</span> <span class="n">display</span><span class="p">,</span> <span class="n">XErrorEvent</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Print e */</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>We first select substructure redirection and substructure notify events on the
root window. This is discussed in more detail in the
<a href="/posts/how-x-window-managers-work-and-how-to-write-one-part-i.html#substructure-redirection">Substructure
Redirection</a> section in Part I; to recap, this allows the window manager to
intercept requests from top level windows, and subscribe to events concerning the
same. Only one X client can select substructure redirection on the root window
at any given time; the second client to attempt to do so will get a <code>BadAccess</code>
error.</p></div>
<div class="paragraph"><p>Catching this error is somewhat tricky, however.
<a href="http://manpages.ubuntu.com/manpages/en/man3/XSelectInput.3.html"><code>XSelectInput</code></a>,
like most Xlib functions, does not actually send a request to the X server, but
instead only <em>queues</em> the request and returns. Hence, we have to explicitly
flush the request queue with
<a href="http://manpages.ubuntu.com/manpages/en/man3/XSync.3.html"><code>XSync</code></a> (see our
discussion above in <a href="#a-tale-of-two-x-libraries">A Tale of Two X Libraries</a>).
We set up a temporary error handler to catch errors.</p></div>
<div class="paragraph"><p>Next, we set up our regular error handler which will be invoked for any future
errors.  Our implementation, which logs the error and continues, will be an
important debugging aid as we implement and test our window manager. I will not
show it here for the sake of brevity; for reference, check it out in
<a href="https://github.com/jichuan89/basic_wm/blob/master/window_manager.cpp"><code>window_manager.cpp</code></a>.</p></div>
</div>
<div class="sect2">
<h3 id="_step_3_the_event_loop">Step 3: The Event Loop</h3>
<div class="paragraph"><p>Now let&#8217;s add to <code>Run()</code> method above the signature construct of every modern
GUI program - the event loop. In
<a href="https://github.com/jichuan89/basic_wm/blob/master/window_manager.cpp"><code>window_manager.cpp</code></a>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="kt">void</span> <span class="n">WindowManager</span><span class="o">::</span><span class="n">Run</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 1. Initialization.</span>
  <span class="p">...</span>

  <span class="c1">// 2. Main event loop.</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="c1">// 1. Get next event.</span>
    <span class="n">XEvent</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">XNextEvent</span><span class="p">(</span><span class="n">display_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Received event: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ToString</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

    <span class="c1">// 2. Dispatch event.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nl">CreateNotify</span><span class="p">:</span>
        <span class="n">OnCreateNotify</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">xcreatewindow</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">DestroyNotify</span><span class="p">:</span>
        <span class="n">OnDestroyNotify</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">xdestroywindow</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">ReparentNotify</span><span class="p">:</span>
        <span class="n">OnReparentNotify</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">xreparent</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">...</span>
      <span class="c1">// etc. etc.</span>
      <span class="p">...</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Ignored event&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>If you have done low-level GUI programming before, this should look fairly
familiar. We sit in an event loop and repeatedly fetch the next event with
<a href="http://manpages.ubuntu.com/manpages/en/man3/XNextEvent.3.html"><code>XNextEvent()</code></a> and
dispatch it to the appropriate handlers.</p></div>
<div class="paragraph"><p>The structure of the <code>XEvent</code> type is typical of a polymorphic C structure.
Each type of event carries different attributes and corresponds to an event
<code>struct</code>, such as <code>XKeyEvent</code>, <code>XButtonEvent</code>, and <code>XConfigureEvent</code>. The first
field of each <code>struct</code> is always <code>int type</code>. The <code>XEvent</code> type is a C
<code>union</code> of all the event <code>structs</code> plus <code>int type</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_XKeyEvent</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
  <span class="c1">// Fields specific to XKeyEvent.</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="n">XKeyEvent</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_XButtonEvent</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
  <span class="c1">// Fields specific to XButtonEvent.</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="n">XButtonEvent</span><span class="p">;</span>

<span class="c1">// etc.</span>
<span class="p">...</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">_XEvent</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
  <span class="n">XKeyEvent</span> <span class="n">xkey</span><span class="p">;</span>
  <span class="n">XButtonEvent</span> <span class="n">xbutton</span><span class="p">;</span>
  <span class="c1">// etc.</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="n">XEvent</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>This way, the type is always available regardless of the type of event and
requires no additional storage. This, of course, is essentially C++ object
inheritance, and the same pattern can be observed in
<a href="http://en.wikipedia.org/wiki/GObject">GTK+/GLib</a>,
<a href="https://docs.python.org/3/c-api/structures.html">Python&#8217;s C API</a>, and many other
object-oriented C APIs.</p></div>
<div class="paragraph"><p>In <code>basic_wm</code>, the event handlers follow the naming convention of <code>OnFoo()</code>,
where <code>Foo</code> is the type of the event, so it should be straightforward to figure
out who does what.</p></div>
</div>
<div class="sect2">
<h3 id="_what_8217_s_next">What&#8217;s Next</h3>
<div class="paragraph"><p>We now have a basic skeleton for our window manager, and we can start filling in
the meat - the event handlers. The million-dollar question is, what events does
a window manager handle, and what should it do with them?</p></div>
<div class="paragraph"><p>In the next installment of this series, we&#8217;ll answer that question by diving
into the complex ways window managers, clients and the user interact with each
other via X events. In the meantime, you&#8217;re more than welcome to check out the
code for <code>basic_wm</code> <a href="https://github.com/jichuan89/basic_wm">on GitHub</a> or browse
the cross-referenced code <a href="http://code.openhub.net/project?pid=&amp;ipid=568869">on
Open Hub</a>.</p></div>
</div>

  </div>

  <footer class="article-info text-muted small">
    <ul class="article-meta text-right">
      <li class="article-author">
        By Chuan Ji
      </li>
      <li class="spacer">|</li>
      <li class="article-date">
        Jun 08, 2014
      </li>
      <li class="spacer">|</li>
      <li>
        Tags:
          <a href="http://seasonofcode.com/tag/featured.html">Featured</a>,          <a href="http://seasonofcode.com/tag/window-manager.html">Window Manager</a>      </li>
      <li class="spacer">|</li>
      <li class="article-comments-count">
        <a href="http://seasonofcode.com/posts/how-x-window-managers-work-and-how-to-write-one-part-ii.html#disqus_thread">Comments</a>
      </li>
      <li class="spacer">|</li>
      <li class="article-link">
        <a href="http://seasonofcode.com/posts/how-x-window-managers-work-and-how-to-write-one-part-ii.html">Permalink</a>
      </li>
    </ul>
  </footer>
</article><div id="author-box">
  <table id="author-box-content">
    <tr>
      <td class="hidden-xs">
        <a rel="author" href="https://plus.google.com/115396580584561637180">
          <div id="author-box-image"
            style="background-image: url(//graph.facebook.com/593659245/picture?type=large)"></div>
        </a>
      </td>
      <td id="author-box-info">
        <p id="author-box-info-title">
          About the author
        </p>
        <p id="author-box-info-bio">
          
I am a software engineer by profession and a passionate technology geek in
my free time.

        </p>
        <p id="author-box-info-links">
          Check out
          <a href="/pages/about.html">my bio</a>, or find me on
          <a href="https://plus.google.com/115396580584561637180">Google+</a>.
        </p>
      </td>
    </tr>
  </table>
</div>
<!-- Comment BEGIN -->
<p></p><p></p>
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'cjix';
  (function() {
      var s = document.createElement('script');
      s.async = true;
      s.type = 'text/javascript';
      s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('HEAD')[0] ||
       document.getElementsByTagName('BODY')[0]).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<!-- Comment END -->
  </section>
        </div>
      </div>
    </div>
    <footer class="footer">
      <div class="container">
        <p class="footer-text text-muted">&copy; 2015 Chuan Ji</p>
      </div>
    </footer>
    <script src="http://seasonofcode.com/theme/jquery.min.js"></script>
    <script src="http://seasonofcode.com/theme/bootstrap/js/bootstrap.min.js"></script>

<script type="text/javascript">
  var disqus_shortname = 'cjix';
  (function () {
      var s = document.createElement('script');
      s.async = true;
      s.type = 'text/javascript';
      s.src = '//' + disqus_shortname + '.disqus.com/count.js';
      (document.getElementsByTagName('HEAD')[0] ||
       document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
</script>

  </body>
</html>